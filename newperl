#! /usr/bin/perl -w

# Create a new Perl script or module file

use strict;
use File::Basename;
use File::Path;
use Getopt::Std;


our $opt_f;
my ($fullPath, $path, $suffix);


# Detect if no params given
if(@ARGV == 0 || $ARGV[0] eq "--help") {
	print <<USAGE;
$0 - Create a new Perl script or module file
version 1.2.1  Dino Morelli  dino\@ui3.info

usage:
   $0 [-f] FILE
   $0 --help

switches:
   -f      Force overwrite existing file
   --help  This information.

FILE is a string describing the new Perl script or module. Examples:
   Foo/Bar.pm
      Makes a file ./Foo/Bar.pm with package Foo::Bar in it
   foo.plx, foo
      Makes an executable script ./foo.plx or ./foo
USAGE
	exit;
}

# Parse arguments
getopts("f");
$fullPath = shift;

(undef, $path, $suffix) = fileparse($fullPath, '\..*');

mkpath($path, 1) if(! -e $path);

# Existing file?
die "File $fullPath exists!\n" if(!$opt_f && -e $fullPath);


my $standardUses = <<USES;
use strict;
use warnings;
USES


if ($suffix && ($suffix =~ m|.p[lm]$|)) {  # Set up new Perl library/module
	# Make the package from the path
	my $package = $fullPath;
	$package =~ s|/|::|g;
	$package =~ s|\.pm||;

	# Create the file
	open (OUTFILE, ">$fullPath") or die "Can't open $fullPath: $!\n";
	print OUTFILE <<MODULE;
package $package;

$standardUses

1;
MODULE
	close (OUTFILE);
} else {  # Set up new Perl binary
	# Locate where perl is on this system
	chomp(my $perlPath = qx/which perl/);

	# Create the file
	open (OUTFILE, ">$fullPath") or die "Can't open $fullPath: $!\n";
	print OUTFILE <<SCRIPT;
#! $perlPath

$standardUses


SCRIPT
	close (OUTFILE);

	# Make the file executable
	print qx/chmod +x $fullPath/;
}

print "file $fullPath created\n";
