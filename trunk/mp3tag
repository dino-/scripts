#! /usr/bin/perl -w

#--------------------------------------------------------------------------
# $RCSfile$
#--------------------------------------------------------------------------
# $Revision: 30 $
# $Date: 2004-06-28 23:42:49 -0400 (Mon, 28 Jun 2004) $
# $Author: dmorelli $
#
# Query or set MP3 ID3v1 tag information
#--------------------------------------------------------------------------
 
use File::Copy;
use Getopt::Std;
use MP3::Tag;


$DEBUG = 0;


#--------------------------------------------------------------------------
sub displayUsage()
{
	print "$0 v1.0.0 - Query or set MP3 ID3 tag information\n";
	print "\nusage:\n";
	print "  $0 [-l] inFile\n";
	print "  $0 -2 inFile\n";
	print "  $0 -b inFile\n";
	print "  $0 -a|w [-k] -t \"key=value\" inFile outFile\n";
	print "  $0 -a|w [-k] -c commentfile inFile outFile\n";
	print "  $0 -k inFile outFile\n";
	print "  $0 --help\n";
	print "\n";
	print "  -a      Append comments\n";
	print "  -c commentfile\n";
	print "          Take comments from a file. The file is the same format as is\n";
	print "          output by the -l option: one element per line in 'tag=value'\n";
	print "          format.\n";
	print "  -k      Kill ID3v2 tags altogether\n";
	print "  -l      List the tags\n";
	print "  -t 'tag=value'\n";
	print "          Tag name and value, can use multiple -t switches\n";
	print "          Specify a new tag on the command line. Each tag is given as a\n";
	print "          single string. The part before the '=' is treated as the tag\n";
	print "          name and the part after as the value.\n";
	print "  -w      Replace comments with the new set given either on the command\n";
	print "          line with -t or from a file with -c.\n";
	print "  --help  Show command help.\n";
	print "\n";
	print "  Valid tag keys are: title artist album comment year track genre\n";
	print "  This program is meant to work almost exactly like vorbiscomment,\n";
	print "  the command help was borrowed nearly word-for-word from it.\n";
	exit;
}  # sub displayUsage


#--------------------------------------------------------------------------
# Show ID3v1 tags for the file
sub showV1Tags($)
{
	$mp3 = new MP3::Tag(shift);
	$mp3->get_tags();

	if (exists $mp3->{ID3v1})
	{
		$id3v1 = $mp3->{ID3v1};
		print "title=", $id3v1->title, "\n";
		print "artist=", $id3v1->artist, "\n";
		print "album=", $id3v1->album, "\n";
		print "comment=", $id3v1->comment, "\n";
		print "year=", $id3v1->year, "\n";
		print "track=", $id3v1->track, "\n";
		print "genre=", $id3v1->genre, "\n";
	}

	$mp3->close();
}  # sub showV1Tags


#--------------------------------------------------------------------------
# Show ID3v2 tags for the file
sub showV2Tags($)
{
	$mp3 = new MP3::Tag(shift);
	$mp3->get_tags();

	if (exists $mp3->{ID3v2})
	{
		$id3v2 = $mp3->{ID3v2};
		$frameIDs_hash = $id3v2->get_frame_ids('truename');

		foreach my $frame (keys %$frameIDs_hash)
		{
			my ($name, @info) = $id3v2->get_frame($frame);
			for my $info (@info)
			{
				if (ref $name)
				{
					print "$frame:\n";
					while(my ($key,$val)=each %$name)
					{ print " * $key => $val\n"; }
				}
				else
				{ print "$name: $info\n"; }
			}
		}  # foreach
	}  # if

	$mp3->close();
}  # sub showV2Tags


#--------------------------------------------------------------------------
# Remove ID3v2 tags.
sub killV2Tags($$)
{
	my ($inPath, $outPath) = @_;

	copy("$inPath", "$outPath") or die "Copy failed: $!";

	$mp3 = new MP3::Tag("$outPath");
	$mp3->get_tags();

	if (exists $mp3->{ID3v2}) { $mp3->{ID3v2}->remove_tag(); }

	$mp3->close();
}  # sub killV2Tags


#--------------------------------------------------------------------------
# Edit ID3v1 tags
sub editV1Tags($$)
{
	my ($inPath, $outPath) = @_;

	copy("$inPath", "$outPath") or die "Copy failed: $!";

	$mp3 = new MP3::Tag("$outPath");
	$mp3->get_tags();

	$id3v1 = $mp3->{ID3v1} if exists $mp3->{ID3v1};

	# No tags in this file, create them.
	if(!defined $id3v1) { $id3v1 = $mp3->new_tag("ID3v1"); }

	# Arg w means get rid of all old tags
	if(defined $opt_w) { $id3v1->remove_tag(); }

	# Lay the new tags in there.
	@keys = keys %tags;
	while (@keys)
	{
		$tagsChanged = 1;
		$_ = shift @keys;
		SWITCH:
		{
			/title/ && do { $id3v1->title($tags{$_}); last SWITCH; };
			/artist/ && do { $id3v1->artist($tags{$_}); last SWITCH; };
			/album/ && do { $id3v1->album($tags{$_}); last SWITCH; };
			/comment/ && do { $id3v1->comment($tags{$_}); last SWITCH; };
			/year/ && do { $id3v1->year($tags{$_}); last SWITCH; };
			/track/ && do { $id3v1->track($tags{$_}); last SWITCH; };
			/genre/ && do { $id3v1->genre($tags{$_}); last SWITCH; };
		}
	}

	if(defined $tagsChanged) { $id3v1->write_tag(); }

	if(defined $opt_k)
	{
		if (exists $mp3->{ID3v2})
			{ $mp3->{ID3v2}->remove_tag(); }
	}

	$mp3->close();
}  # sub editV1Tags


#--------------------------------------------------------------------------
sub loadCommentFile($)
{
	my $commentPath = shift;

	open (COMMENT_FILE, "$commentPath") || die "Can't open $commentPath\n";
	while (<COMMENT_FILE>)
	{
		# Get rid of the trailing newline.
		chop;

		/(.*)=(.*)/;
		$tags{$1} = $2;
	}
	close COMMENT_FILE;
}  # sub loadCommentFile


#--------------------------------------------------------------------------
# No args at all or user requested help.
if(@ARGV == 0 || $ARGV[0] eq "--help") { displayUsage(); }

# Parse the args
while (@ARGV)
{
	$_ = shift;
	SWITCH:
	{
		/^-2/ && do { $anySwitches = 1; $opt_2 = 1; last SWITCH; };
		/^-a/ && do { $anySwitches = 1; $opt_a = 1; last SWITCH; };
		/^-b/ && do { $anySwitches = 1; $opt_b = 1; last SWITCH; };
		/^-c/ && do
		{
			$anySwitches = 1;
			loadCommentFile(shift);
			last SWITCH;
		};
		/^-k/ && do { $anySwitches = 1; $opt_k = 1; last SWITCH; };
		/^-l/ && do { $anySwitches = 1; $opt_l = 1; last SWITCH; };
		/^-t/ && do
		{
			shift =~ /(.*)=(.*)/;
			$tags{$1} = $2;
			last SWITCH;
		};
		/^-w/ && do { $anySwitches = 1; $opt_w = 1; last SWITCH; };

		# Remaining non-switches are the file paths.
		if(defined $inPath) { $outPath = $_; }
		else { $inPath = $_; }
	}
}  # while

# No switches means show tags.
if(!defined $anySwitches) { $opt_l = 1; }

#Debugging
if($DEBUG)
{
	print "--\n";
	print "opt_2: ", (defined $opt_2 ? $opt_2 : "[undefined]"), "\n";
	print "opt_a: ", (defined $opt_a ? $opt_a : "[undefined]"), "\n";
	print "opt_b: ", (defined $opt_b ? $opt_b : "[undefined]"), "\n";
	print "opt_c: ", (defined $opt_c ? $opt_c : "[undefined]"), "\n";
	print "opt_k: ", (defined $opt_k ? $opt_k : "[undefined]"), "\n";
	print "opt_l: ", (defined $opt_l ? $opt_l : "[undefined]"), "\n";
	#print "opt_t: ", (defined $opt_t ? $opt_t : "[undefined]"), "\n";
	print "opt_w: ", (defined $opt_w ? $opt_w : "[undefined]"), "\n";
	print "inPath: ", (defined $inPath ? $inPath : "[undefined]",
		"\n");
	print "outPath: ", (defined $outPath ? $outPath : "[undefined]",
		"\n");
	print "--\n";
}

# No file given, this is bad.
if(!defined $inPath)
{
	print "No input MP3 file path given.\n";
	displayUsage();
}

# Figure out what to do based on the switches
if(defined $opt_l) { showV1Tags($inPath); }
elsif(defined $opt_2) { showV2Tags($inPath); }
elsif(defined $opt_b)
{
	print "ID3v1 tags\n";
	showV1Tags($inPath);
	print "\nID3v2 tags\n";
	showV2Tags($inPath);
}
elsif((defined $opt_a) || (defined $opt_w))
{
	if(!defined $outPath)
	{
		print "No output MP# file path given.\n";
		displayUsage();
	}
	editV1Tags($inPath, $outPath);
}
elsif(defined $opt_k)
{
	if(!defined $outPath)
	{
		print "No output MP# file path given.\n";
		displayUsage();
	}
	killV2Tags($inPath, $outPath);
}
